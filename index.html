<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DLX Exact Cover Solver</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <div class="container">
    <h1>Dancing Links Solver</h1>

    <!-- Grid setup -->
    <div class="grid-setup">
      <label for="gridRows">Rows:</label>
      <input type="number" id="gridRows" min="1" max="20" />
      <label for="gridCols">Columns:</label>
      <input type="number" id="gridCols" min="1" max="20" />
      <button onclick="generateLetterGrid()">Create Grid</button>
      <button onclick="extractGrid()">Log Grid to Console</button>
      <button onclick="convertGridToDLX()">Generate from Grid</button>
    </div>

    <!-- Dynamic grid appears here -->
    <div id="letterGridContainer"></div>

    <!-- DLX input -->
    <textarea id="matrixInput" placeholder="Enter binary matrix, one row per line (e.g. 1 0 1)"></textarea>
    <button onclick="solve()">Solve</button>
    <pre id="output"></pre>
  </div>

  <script src="dlx.js"></script>
  <script>
    function generateLetterGrid() {
      const rows = parseInt(document.getElementById("gridRows").value);
      const cols = parseInt(document.getElementById("gridCols").value);
      const container = document.getElementById("letterGridContainer");
      container.innerHTML = "";

      if (!rows || !cols || rows < 1 || cols < 1) {
        alert("Please enter valid grid dimensions.");
        return;
      }

      const cellSize = Math.max(20, 40 - Math.max(rows, cols)); // Adjust size for large grids
      const table = document.createElement("table");

      for (let r = 0; r < rows; r++) {
        const tr = document.createElement("tr");
        for (let c = 0; c < cols; c++) {
          const td = document.createElement("td");
          const input = document.createElement("input");
          input.type = "text";
          input.maxLength = 1;
          input.style.width = input.style.height = `${cellSize}px`;
          td.appendChild(input);
          tr.appendChild(td);
        }
        table.appendChild(tr);
      }

      container.appendChild(table);
    }


    function extractGrid() {
      const container = document.getElementById("letterGridContainer");
      const rows = container.querySelectorAll("tr");
      const grid = [];

      rows.forEach(row => {
        const inputs = row.querySelectorAll("input");
        const rowData = [];
        inputs.forEach(input => {
          rowData.push(input.value.toUpperCase() || " ");
        });
        grid.push(rowData);
      });

      console.log("Extracted Grid:");
      console.table(grid);
      alert("Grid logged to console.");
    }

    async function loadDictionary(url) {
      const response = await fetch(url);
      const text = await response.text();
      const words = text.split(/\r?\n/).map(w => w.trim().toLowerCase()).filter(w => w.length);
      return buildTrie(words);
    }

    function buildTrie(words) {
      const root = {};
      for (const word of words) {
        let node = root;
        for (const char of word) {
          node[char] = node[char] || {};
          node = node[char];
        }
        node.isWord = true;
      }
      return root;
    }

    function hasPrefix(trie, prefix) {
      let node = trie;
      for (const char of prefix) {
        if (!node[char]) return false;
        node = node[char];
      }
      return true;
    }

    function isWord(trie, word) {
      let node = trie;
      for (const char of word) {
        if (!node[char]) return false;
        node = node[char];
      }
      return !!node.isWord;
    }

    function findWordsInGrid(grid, trie) {
      const rows = grid.length;
      const cols = grid[0].length;
      const directions = [
        [-1, -1], [-1, 0], [-1, 1],
        [0, -1], [0, 1],
        [1, -1], [1, 0], [1, 1]
      ];

      const found = {};

      function dfs(x, y, path, positions, visited) {
        const char = grid[x][y].toLowerCase();
        const newPath = path + char;
        const pos = x * cols + y + 1;
        const newPositions = [...positions, pos];

        if (!hasPrefix(trie, newPath)) return;
        if (isWord(trie, newPath) && newPath.length > 3) {
          found[newPath] = newPositions;
        }

        visited[x][y] = true;

        for (const [dx, dy] of directions) {
          const nx = x + dx, ny = y + dy;
          if (
            nx >= 0 && nx < rows &&
            ny >= 0 && ny < cols &&
            !visited[nx][ny]
          ) {
            dfs(nx, ny, newPath, newPositions, visited.map(r => [...r]));
          }
        }

        visited[x][y] = false;
      }

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
          dfs(i, j, "", [], visited);
        }
      }

      return found;
    }

    function formatDLX(foundWords, gridRows, gridCols) {
      const sets = Object.values(foundWords)
        .map(path => `{${path.join(",")}}`);
      const total = gridRows * gridCols;
      const allIndexes = Array.from({ length: total }, (_, i) => i + 1);
      return `{${sets.join(",")} : ${allIndexes.join(",")}}`;
    }

    function extractGridFromUI() {
      const table = document.querySelector("#letterGridContainer table");
      const rows = Array.from(table.rows);
      return rows.map(row =>
        Array.from(row.cells).map(cell =>
          cell.querySelector("input").value || " "
        )
      );
    }

    async function convertGridToDLX() {
      const grid = extractGridFromUI();
      const trie = await loadDictionary('words_alpha.txt'); // You must host this file or use a short word list.
      const foundWords = findWordsInGrid(grid, trie);
      const dlxFormat = formatDLX(foundWords, grid.length, grid[0].length);

      document.getElementById("matrixInput").value = dlxFormat;
      console.log("DLX Matrix Generated:\n", dlxFormat);
    }

  </script>
</body>

</html>